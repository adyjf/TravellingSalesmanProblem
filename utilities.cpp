#include <iostream>
#include <chrono>
#include <cstring>
#include <lemon/core.h>
#include <lemon/list_graph.h>
#include <lemon/adaptors.h>
#include <lemon/lgf_reader.h>
#include <lemon/concepts/digraph.h>
#include <lemon/smart_graph.h>
#include <lemon/kruskal.h>
#include <lemon/lgf_writer.h>

using namespace lemon;

int UPPER_BOUND = 9999;
bool image = false;
bool print = false;
bool hide = false;
SmartDigraph::Node source, target;

/*
parseCommandLine: récupère les arguments lors du lancement
Arguments:
    argc: nombre d'arguments
    argv: arguments
    filemeName: nom du fichier LGF
Return: 
    0 si aucun argument
    1 si arguments corrects
    -1 si arguments incorrects
*/
int parseCommandLine(int *argc, char **argv, std::string *fileName){
  if(*argc == 1){
    std::cout << "TSP: Traveling Salesman Problem solver using Branch and Bound" << std::endl;
    std::cout << "Use \"./TSP --help\" for more informations." << std::endl;
    return 0;
  }

  for(int i=1; i<*argc; i++){
    if(strcmp(argv[i], "-d")==0 || strcmp(argv[i], "--demo")==0){
      *fileName = "instances/data/demo.lgf";
    }
    else if(strcmp(argv[i], "-f")==0 || strcmp(argv[i], "--file")==0){
      if(i<*argc-1){
        *fileName = argv[i+1];
        i++;
      }
      else{
        std::cerr << "Error: No file name" << std::endl;
        return -1;
      }
    }
    else if(strcmp(argv[i], "-h")==0 || strcmp(argv[i], "--hide")==0){
      hide = true;
    }
    else if(strcmp(argv[i], "-i")==0 || strcmp(argv[i], "--image")==0){
      image = true;
    }
    else if(strcmp(argv[i], "-p")==0 || strcmp(argv[i], "--print")==0){
      print = true;
    }
    else if(strcmp(argv[i], "--help")==0){
      std::cout << "\e[1mNAME\e[0m\n\tTraveling Salesman Problem - solve the traveling Salesman problem\n" << std::endl;

      std::cout << 
      "\e[1mDESCRIPTION\e[0m\n\tCompute the minmum weight Hamiltonian circuit on the given graph, using branch and bound method. Return a list of the arcs of the graph, followed by 0 if it is not part of the minmum weight Hamiltonian circuit; 1 if it is part of the minmum weight Hamiltonian circuit.\n"
      << "\n\tMandatory  arguments  to  long  options are mandatory for short options too.\n"
      << std::endl;

      std::cout << 
      "\t\e[1m-d, --demo\e[0m\n\t\tLaunch the algorithm on demo graph\n"
        << "\n\t\e[1m-f, --file\e[0m <FILE>\n\t\tLaunch the algorithm on graph generated by FILE; FILE must be a LEMON Graph Format (LGF) file; see LGF format at http://lemon.cs.elte.hu/pub/doc/1.2.3/a00002.html\n"
        << "\n\t\e[1m--help\e[0m\n\t\tDisplay help\n"
        << "\n\t\e[1m-h, --hide\e[0m\n\t\tHide the LowerBound and UpperBound during computation\n"
        << "\n\t\e[1m-i, --image\e[0m\n\t\tGenerate JPEG file for the solution named NAME.jpg\n"
        << "\n\t\e[1m-p, --print\e[0m\n\t\tPrint current solution\n"
      << std::endl;
      return 0;
    }
    else{
      std::cout << "Option not valid" << std::endl;
    }
  }

  std::cout << "Launching on: " << *fileName << std::endl;
  std::cout << "Options: " << std::endl;
  std::cout <<"\timage: " << image << std::endl;
  std::cout <<"\tprint: " << print << std::endl;
  std::cout <<"\thide: " << hide << std::endl;

  return 1;
}

/*
displayDigraph: affiche le graphe digraph
Arguments:
    digraph: Digraph structure concepts de LEMON
    weight: ArcMap structure concepts de LEMON
*/
template<typename T, typename U>
void displayDigraph(const T& digraph, const U& weight){
  std::cout << "-----Displaying digraph-----" << std::endl;
  std::cout << "Number of nodes: " << countNodes(digraph) << std::endl;
  std::cout << "Number of arcs: " << countArcs(digraph) << std::endl;
  digraphWriter(digraph).
    arcMap("capacity", weight).
    run();
  std::cout << "----------------------------" << std::endl;
}

/*
copyArcMap: crée une copie de arc_map dans arc_map2
*/
void copyArcMap(const SmartDigraph *digraph, const SmartDigraph::ArcMap<bool> *arc_map, SmartDigraph::ArcMap<bool> *arc_map2){
  for(SmartDigraph::ArcIt i(*digraph); i!=INVALID; ++i)
    (*arc_map2)[i] = (*arc_map)[i];
}

/*
orArcMap: arc_map3 = arc_map OR arc_map2
*/
void orArcMap(const SmartDigraph *digraph, const SmartDigraph::ArcMap<bool> *arc_map, const SmartDigraph::ArcMap<bool> *arc_map2, SmartDigraph::ArcMap<bool> *arc_map3){
  for(SmartDigraph::ArcIt i(*digraph); i!=INVALID; ++i){
    if((*arc_map)[i] || (*arc_map2)[i])
      (*arc_map3)[i] = true;
  }
}

/*
hideNode: 
*/
void hideNode(SmartDigraph *digraph, 
	      SmartDigraph::NodeMap<bool> *node_map,
	      SmartDigraph::ArcMap<bool> *path_map,
	      SmartDigraph::NodeMap<bool> *min_span_tree_node_map){
  SubDigraph<SmartDigraph> sub_digraph(*digraph, *node_map, *path_map);
  
  for(SubDigraph<SmartDigraph>::NodeIt n(sub_digraph); n!=INVALID; ++n){
    if((countInArcs(sub_digraph, n)==1 && countOutArcs(sub_digraph, n)==1)){
      (*min_span_tree_node_map)[n] = false;
    }
  }
}

/*
printPath: affiche le chemin path_map
*/
void printPath(SmartDigraph *digraph,
	       SmartDigraph::Node *node,
	       SmartDigraph::NodeMap<bool> *node_map,
	       SmartDigraph::ArcMap<bool> *path_map){
  SubDigraph<SmartDigraph> sub_digraph(*digraph, *node_map, *path_map);
  SmartDigraph::Node current_node = *node;
  SmartDigraph::Arc arc;
  
  std::cout << digraph->id(current_node);
  do{
    sub_digraph.firstOut(arc, current_node);
    std::cout << " -> " << digraph->id(digraph->target(arc));
    current_node = digraph->target(arc);
  }while(current_node != *node);
  if(hide)
    std::cout << std::endl;
}

/*
isHamiltonianCycle: vérifie si un graphe est hamiltonien
*/
bool isHamiltonianCycle(SmartDigraph *digraph, 
			SmartDigraph::Node *node,
			SmartDigraph::NodeMap<bool> *node_map,
			SmartDigraph::ArcMap<bool> *arc_map){
  SmartDigraph::NodeMap<bool> visited(*digraph, false);
  SmartDigraph::Node current_node = *node;
  SmartDigraph::Arc arc;
  SmartDigraph::Node current_node2 = *node;
  SmartDigraph::Arc arc2;
  
  SubDigraph<SmartDigraph> sub_digraph(*digraph, *node_map, *arc_map);
  
  // vérifier que chaque noeud a une arête entrante et une sortante
  for(SmartDigraph::NodeIt n(*digraph); n!=INVALID; ++n){
    if(countInArcs(sub_digraph, n)>1 || countOutArcs<>(sub_digraph, n)>1){
      return false;
    }
  }
  
  visited[current_node] = true;
  while(1){
    sub_digraph.firstOut(arc, current_node);
    sub_digraph.firstIn(arc2, current_node2);
    
    if(!visited[sub_digraph.target(arc)] || !visited[sub_digraph.source(arc2)]){
      if(!visited[sub_digraph.target(arc)]){
	visited[sub_digraph.target(arc)] = true;
	current_node = sub_digraph.target(arc);
      }
      if(!visited[sub_digraph.source(arc2)]){
	visited[sub_digraph.source(arc2)] = true;
	current_node2 = sub_digraph.source(arc2);
      }
    }
    else{
      break;
    }
  }
  
  //check si tous les noeuds ont été visités
  for(SmartDigraph::NodeIt i(*digraph); i!=INVALID; ++i){
    if(!visited[i])
      return false;
  }

  return true;
}

/*
isSubTour: vérifie si c'est un sous-graphe de digraph
*/
bool isSubTour(SmartDigraph *digraph, 
	       SmartDigraph::Node *node,
	       SmartDigraph::NodeMap<bool> *node_map,
	       SmartDigraph::ArcMap<bool> *arc_map){
//   SmartDigraph::NodeMap<bool> visited(*digraph, false);
//   SmartDigraph::Node current_node = *node;
//   SmartDigraph::Arc arc;

  SubDigraph<SmartDigraph> sub_digraph(*digraph, *node_map, *arc_map);
  for(SubDigraph<SmartDigraph>::NodeIt n(sub_digraph); n!=INVALID; ++n){
    if(countInArcs(sub_digraph, n)>1)
      return true;
  }
  
//   visited[current_node] = true;
//   while(1){
//     sub_digraph.firstOut(arc, current_node);
//     current_node = sub_digraph.target(arc);
//     if(!visited[current_node]){
//       visited[current_node] = true;
//     }
//     else{
//       break;
//     }
//   }
//   if(current_node == *node)
//     return true;
  
  return false;
}

/*
BB: algorithme de Branch and Bound
*/
void BB(SmartDigraph *digraph,
	SmartDigraph::Node *node,
	SmartDigraph::NodeMap<bool> *node_map,
	SmartDigraph::ArcMap<bool> *path_map,
	SmartDigraph::ArcMap<bool> *min_span_tree_arc_map,
	SmartDigraph::ArcMap<bool> *best_path,
	SmartDigraph::ArcMap<int> *weight){
  // lower_bound du noeud
  int lower_bound = -9999;

  SubDigraph<SmartDigraph> sub_digraph(*digraph, *node_map, *path_map);
  
  auto runUntil = std::chrono::system_clock::now() + std::chrono::seconds(7200);
  for(SubDigraph<SmartDigraph>::OutArcIt i(sub_digraph, *node); i!=INVALID && std::chrono::system_clock::now() < runUntil; ++i){
    // enlève arête i et son opposé j
    (*path_map)[i] = false;
    (*min_span_tree_arc_map)[i] = true;
    for(SmartDigraph::InArcIt j(*digraph, *node); j!=INVALID; ++j){
      if(digraph->source(j)==digraph->target(i) && digraph->source(i)==digraph->target(j))
        (*path_map)[j] = false;
    }

    //==================================================
    SmartDigraph::NodeMap<bool> min_span_tree_node_map(*digraph, true);
    hideNode(digraph, node_map, min_span_tree_arc_map, &min_span_tree_node_map);
    
    // calcul MinimumSpanningTree sur le sous-graphe
    SubDigraph<SmartDigraph> min_span_tree(*digraph, min_span_tree_node_map, *path_map);
    SubDigraph<SmartDigraph>::ArcMap<bool> tree_map(min_span_tree);
    
    lower_bound = kruskal(min_span_tree, *weight, tree_map);
    for(SmartDigraph::ArcIt j(*digraph); j!=INVALID; ++j){
      if((*min_span_tree_arc_map)[j])
        lower_bound += (*weight)[j];
    }
    
    SmartDigraph::ArcMap<bool> current_path(*digraph, false);
    orArcMap(digraph, min_span_tree_arc_map, &tree_map, &current_path);
    
    if(!hide)
      std::cout << "LB = " << lower_bound << ", UB = " << UPPER_BOUND << "\t";
    if(print && UPPER_BOUND<9999)
      printPath(digraph, &source, node_map, best_path);
    if(!hide)
      std::cout << std::endl;

    if((lower_bound < UPPER_BOUND) && (isHamiltonianCycle(digraph, node, node_map, &current_path))){
      UPPER_BOUND = lower_bound;
      copyArcMap(digraph, &current_path, best_path);
    }
    else if((lower_bound < UPPER_BOUND) && (isSubTour(digraph, node, node_map, min_span_tree_arc_map)==false)){
      SmartDigraph::Node current_node = digraph->target(i);
      BB(digraph, &current_node, node_map, path_map, min_span_tree_arc_map, best_path, weight);
    }
    
//==================================================
    //remet arête i et son opposé j
    (*path_map)[i] = true;
    (*min_span_tree_arc_map)[i] = false;
    for(SmartDigraph::InArcIt j(*digraph, *node); j!=INVALID; ++j){
      if(digraph->source(j)==digraph->target(i) && digraph->source(i)==digraph->target(j))
        (*path_map)[j] = true;
    }
  }
}


